import numpy as np
from itertools import combinations

def ranking_loss(y_true, y_pred1, y_pred2, y_pred3):
    """
    计算两个预测模型的Ranking Loss
    
    参数:
    y_true -- 真实值的列表/数组
    y_pred1 -- 模型1预测值的列表/数组
    y_pred2 -- 模型2预测值的列表/数组
    
    返回:
    loss1 -- 模型1的Ranking Loss
    loss2 -- 模型2的Ranking Loss
    """
    # 转换为numpy数组
    y_true = np.array(y_true)
    y_pred1 = np.array(y_pred1)
    y_pred2 = np.array(y_pred2)
    y_pred3 = np.array(y_pred3)
    
    # 检查输入长度是否一致
    assert len(y_true) == len(y_pred1) == len(y_pred2) == len(y_pred3), "输入列表长度必须相等"
    
    # 生成所有可能的样本对
    pairs = list(combinations(range(len(y_true)), 2))

    print("Number of pairs:", len(pairs))
    
    def calculate_loss(y_true, y_pred):
        loss = 0
        valid_pairs = 0
        
        for i, j in pairs:
            # 只计算有明确排序关系的对
            if y_true[i] == y_true[j]:
                continue
                
            valid_pairs += 1
            
            # 确定真实排序关系
            if y_true[i] > y_true[j]:
                true_order = 1
            else:
                true_order = -1
                
            # 确定预测排序关系
            if y_pred[i] > y_pred[j]:
                pred_order = 1
            else:
                pred_order = -1
                
            # 计算损失（0-1损失）
            loss += 0 if true_order == pred_order else 1
        
        return loss / valid_pairs if valid_pairs > 0 else 0
    
    # 计算两个模型的Ranking Loss
    loss1 = calculate_loss(y_true, y_pred1)
    loss2 = calculate_loss(y_true, y_pred2)
    loss3 = calculate_loss(y_true, y_pred3)

    return loss1, loss2, loss3

# 示例使用
if __name__ == "__main__":
    # 示例数据
#     y_true = [0.43365283,
# 0.482496834,
# 0.658162785,
# 0.649146938,
# 0.968109274,
# 0.211307764,
# 0.812900305,
# 0.322409201,
# 1.202109861,
# 0.760819101,
# 0.301182604,
# 0.731854296,
# 0.164769554,
# 0.422353506,
# 0.595374966,
# 0.652197695,
# 1.181112003,
# 0.65670085,
# 0.83635745,
# 0.358542204,
# 1.164412022,
# 0.131415367
# ]  # 真实相关性分数（越高表示越相关）
    y_true = [0.003264904022216797,
0.10146293640136719,
0.2622672080993652,
0.3365775585174561,
0.6482796192169189,
0.11384763717651367,
0.535621452331543,
0.17969141006469727,
1.0526582241058349,
0.45927915573120115,
0.07392692565917969,
0.5502703666687012,
0.0563410758972168,
0.23112897872924804,
0.2804460048675537,
0.5378016948699951,
1.1153319835662843,
0.502465295791626,
0.590888261795044,
0.24265074729919434,
1.0033236980438232,
0.07481255531311035]
    
    y_model1 = [101777.82,
260024,
93648082.78,
91342360.82,
93550432.82,
3001044,
3289164,
4489056,
3241044,
3289044,
250101,
3301135.2,
248000,
3001044,
3001044,
264000,
72889921.35,
300091.2,
3241044,
3265104,
300151.2,
258000
]  # 模型1预测分数
    y_model2 = [10464763.77110447,
48927142.24950237,
127287222.7950596,
117536920.16481312,
156792728.24317703,
103738088.31386343,
177454868.50521562,
169022270.47430822,
188303761.77899307,
137280600.14846238,
19967439.262708317,
118204666.29846928,
19814123.451087505,
16422624.84561212,
135103568.66651747,
39309000.53430173,  
181040196.65635085,
131184862.74105503,
164237606.52774227,
144337729.19142398,
173530896.0989066,
18874946.331992548
]  # 模型2预测分数
    
    y_model3 =[165860426.27110445,
72677379.7495024,
199812740.29505965,
182632582.6648131,
265589815.74317697,
163133750.81386346,
222551718.5052156,
257868170.47430825,
222449424.2789931,
202376262.6484624,
29968626.762708317,
183539633.7984693,
25514123.451087505,
175818287.34561214,
194499231.16651744,
44534000.53430173,
382629395.89433837,
137124167.74105504,
178383269.02774227,
208959579.19142398,
238867051.09890667,
17574946.331992548
    ]
    
    loss1, loss2, loss3 = ranking_loss(y_true, y_model1, y_model2, y_model3)
    
    print(f"模型1的Ranking Loss: {loss1:.4f}")
    print(f"模型2的Ranking Loss: {loss2:.4f}")
    print(f"模型3的Ranking Loss: {loss3:.4f}")
    
    # if loss1 < loss2:
    #     print("模型1的排序性能更好")
    # else:
    #     print("模型2的排序性能更好")